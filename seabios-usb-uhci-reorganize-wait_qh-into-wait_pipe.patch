From 95ce7316b569de4d68cdbf01f4e2cbaa13b9695c Mon Sep 17 00:00:00 2001
From: Paolo Bonzini <pbonzini@redhat.com>
Date: Fri, 27 Jan 2012 16:35:53 +0100
Subject: [PATCH 02/22] usb-uhci: reorganize wait_qh into wait_pipe

RH-Author: Paolo Bonzini <pbonzini@redhat.com>
Message-id: <1327682173-30723-3-git-send-email-pbonzini@redhat.com>
Patchwork-id: 36981
O-Subject: [RHEL6.3 PATCH seabios 02/22] usb-uhci: reorganize wait_qh into wait_pipe
Bugzilla: 782028
RH-Acked-by: Laszlo Ersek <lersek@redhat.com>
RH-Acked-by: Markus Armbruster <armbru@redhat.com>
RH-Acked-by: Alon Levy <alevy@redhat.com>

Four changes:

1) Add explicit GET_FLATPTR/SET_FLATPTR.

2) Pass the whole pipe to wait_qh so that we can get the iobase from there.

3) Clean up the pipe upon timeout, since that is the only sensible
thing to do: tds are on the stack, and leaving pointers to them in
the pipe is not a good idea.

4) Add a variable timeout argument, since bulk transfers might take more
than 500 ms.

Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry-picked from 31dfd3f20d66604d6959e86c97add01523f65883)
---
 src/usb-uhci.c |   64 ++++++++++++++++++++++++++-----------------------------
 1 files changed, 30 insertions(+), 34 deletions(-)

Signed-off-by: Michal Novotny <minovotn@redhat.com>
---
 src/usb-uhci.c |   64 ++++++++++++++++++++++++++-----------------------------
 1 files changed, 30 insertions(+), 34 deletions(-)

diff --git a/src/usb-uhci.c b/src/usb-uhci.c
index 40f83bb..8bdbecd 100644
--- a/src/usb-uhci.c
+++ b/src/usb-uhci.c
@@ -207,26 +207,13 @@ uhci_init(u16 bdf, int busid)
  * End point communication
  ****************************************************************/
 
-static int
-wait_qh(struct usb_uhci_s *cntl, struct uhci_qh *qh)
-{
-    // XXX - 500ms just a guess
-    u64 end = calc_future_tsc(500);
-    for (;;) {
-        if (qh->element & UHCI_PTR_TERM)
-            return 0;
-        if (check_tsc(end)) {
-            warn_timeout();
-            struct uhci_td *td = (void*)(qh->element & ~UHCI_PTR_BITS);
-            dprintf(1, "Timeout on wait_qh %p (td=%p s=%x c=%x/%x)\n"
-                    , qh, td, td->status
-                    , inw(cntl->iobase + USBCMD)
-                    , inw(cntl->iobase + USBSTS));
-            return -1;
-        }
-        yield();
-    }
-}
+struct uhci_pipe {
+    struct uhci_qh qh;
+    struct uhci_td *next_td;
+    struct usb_pipe pipe;
+    u16 iobase;
+    u8 toggle;
+};
 
 // Wait for next USB frame to start - for ensuring safe memory release.
 static void
@@ -246,13 +233,28 @@ uhci_waittick(u16 iobase)
     }
 }
 
-struct uhci_pipe {
-    struct uhci_qh qh;
-    struct uhci_td *next_td;
-    struct usb_pipe pipe;
-    u16 iobase;
-    u8 toggle;
-};
+static int
+wait_pipe(struct uhci_pipe *pipe, int timeout)
+{
+    u64 end = calc_future_tsc(timeout);
+    for (;;) {
+        u32 el_link = GET_FLATPTR(pipe->qh.element);
+        if (el_link & UHCI_PTR_TERM)
+            return 0;
+        if (check_tsc(end)) {
+            warn_timeout();
+            struct uhci_td *td = (void*)(el_link & ~UHCI_PTR_BITS);
+            dprintf(1, "Timeout on wait_pipe %p (td=%p s=%x c=%x/%x)\n"
+                    , pipe, (void*)el_link, GET_FLATPTR(td->status)
+                    , inw(pipe->iobase + USBCMD)
+                    , inw(pipe->iobase + USBSTS));
+            SET_FLATPTR(pipe->qh.element, UHCI_PTR_TERM);
+            uhci_waittick(pipe->iobase);
+            return -1;
+        }
+        yield();
+    }
+}
 
 void
 uhci_free_pipe(struct usb_pipe *p)
@@ -326,8 +328,6 @@ uhci_control(struct usb_pipe *p, int dir, const void *cmd, int cmdsize
         return -1;
     dprintf(5, "uhci_control %p\n", p);
     struct uhci_pipe *pipe = container_of(p, struct uhci_pipe, pipe);
-    struct usb_uhci_s *cntl = container_of(
-        pipe->pipe.cntl, struct usb_uhci_s, usb);
 
     int maxpacket = pipe->pipe.maxpacket;
     int lowspeed = pipe->pipe.speed;
@@ -371,11 +371,7 @@ uhci_control(struct usb_pipe *p, int dir, const void *cmd, int cmdsize
     // Transfer data
     barrier();
     pipe->qh.element = (u32)&tds[0];
-    int ret = wait_qh(cntl, &pipe->qh);
-    if (ret) {
-        pipe->qh.element = UHCI_PTR_TERM;
-        uhci_waittick(pipe->iobase);
-    }
+    int ret = wait_pipe(pipe, 500);
     free(tds);
     return ret;
 }
-- 
1.7.7.6

