From 63e163482cb695a6f1aa5d3bf89f2a78a6f81d82 Mon Sep 17 00:00:00 2001
Message-Id: <63e163482cb695a6f1aa5d3bf89f2a78a6f81d82.1347373749.git.minovotn@redhat.com>
In-Reply-To: <60f5a5c59dffe1a436d9e5ed4f1f1d3c8267eb9d.1347373749.git.minovotn@redhat.com>
References: <60f5a5c59dffe1a436d9e5ed4f1f1d3c8267eb9d.1347373749.git.minovotn@redhat.com>
From: Gleb Natapov <gleb@redhat.com>
Date: Mon, 3 Sep 2012 08:49:09 +0200
Subject: [PATCH 3/7] acpi: extract aml from .lst

RH-Author: Gleb Natapov <gleb@redhat.com>
Message-id: <1346662153-18382-4-git-send-email-gleb@redhat.com>
Patchwork-id: 41587
O-Subject: [PATCH RHEL6.4 3/7] acpi: extract aml from .lst
Bugzilla: 827500
RH-Acked-by: Paolo Bonzini <pbonzini@redhat.com>
RH-Acked-by: Igor Mammedov <imammedo@redhat.com>
RH-Acked-by: Laszlo Ersek <lersek@redhat.com>

Add ACPI_EXTRACT_ALL_CODE directive, to support extracting
AML code from listing into a named array. Use that instead including C
file generated by iasl, this makes it possible to include multiple AML
tables without resorting to preprocessor tricks.

Signed-off-by: Michael S. Tsirkin <mst@redhat.com>

Upstream: 2e55b03e6314b6cf282dd2d911598973b37a9ca4

Signed-off-by: Gleb Natapov <gleb@redhat.com>
---
 Makefile              |    2 +-
 src/acpi-dsdt.dsl     |    3 +++
 tools/acpi_extract.py |   33 ++++++++++++++++++++++-----------
 3 files changed, 26 insertions(+), 12 deletions(-)

Signed-off-by: Michal Novotny <minovotn@redhat.com>
---
 Makefile              |  2 +-
 src/acpi-dsdt.dsl     |  3 +++
 tools/acpi_extract.py | 33 ++++++++++++++++++++++-----------
 3 files changed, 26 insertions(+), 12 deletions(-)

diff --git a/Makefile b/Makefile
index 327cf00..d9cecb0 100644
--- a/Makefile
+++ b/Makefile
@@ -190,7 +190,7 @@ src/%.hex: src/%.dsl ./tools/acpi_extract_preprocess.py ./tools/acpi_extract.py
 	$(Q)./tools/acpi_extract_preprocess.py $(OUT)$*.dsl.i.orig > $(OUT)$*.dsl.i
 	$(Q)iasl -l -tc -p $(OUT)$* $(OUT)$*.dsl.i
 	$(Q)./tools/acpi_extract.py $(OUT)$*.lst > $(OUT)$*.off
-	$(Q)cat $(OUT)$*.hex $(OUT)$*.off > $@
+	$(Q)cat $(OUT)$*.off > $@
 
 $(OUT)ccode32flat.o: src/acpi-dsdt.hex
 
diff --git a/src/acpi-dsdt.dsl b/src/acpi-dsdt.dsl
index ac39b7e..531846a 100644
--- a/src/acpi-dsdt.dsl
+++ b/src/acpi-dsdt.dsl
@@ -16,6 +16,9 @@
  * License along with this library; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
+
+ACPI_EXTRACT_ALL_CODE AmlCode
+
 DefinitionBlock (
     "acpi-dsdt.aml",    // Output Filename
     "DSDT",             // Signature
diff --git a/tools/acpi_extract.py b/tools/acpi_extract.py
index 9083cff..5f613e4 100755
--- a/tools/acpi_extract.py
+++ b/tools/acpi_extract.py
@@ -29,6 +29,8 @@
 # ACPI_EXTRACT_PROCESSOR_START - start of Processor() block
 # ACPI_EXTRACT_PROCESSOR_STRING - extract a NameString from Processor()
 # ACPI_EXTRACT_PROCESSOR_END - offset at last byte of Processor() + 1
+#
+# ACPI_EXTRACT_ALL_CODE - create an array storing the generated AML bytecode
 # 
 # ACPI_EXTRACT is not allowed anywhere else in code, except in comments.
 
@@ -240,6 +242,11 @@ for i in range(len(asl)):
     array = mext.group(2)
     offset = asl[i].aml_offset
 
+    if (directive == "ACPI_EXTRACT_ALL_CODE"):
+        if array in output:
+            die("%s directive used more than once" % directive)
+        output[array] = aml
+        continue
     if (directive == "ACPI_EXTRACT_NAME_DWORD_CONST"):
         offset = aml_name_dword_const(offset)
     elif (directive == "ACPI_EXTRACT_NAME_WORD_CONST"):
@@ -261,21 +268,25 @@ for i in range(len(asl)):
 
     if array not in output:
         output[array] = []
-    output[array].append("0x%x" % offset)
+    output[array].append(offset)
 
 debug = "at end of file"
 
-#Use type large enough to fit the table
-if (len(aml) >= 0x10000):
-	offsettype = "int"
-elif (len(aml) >= 0x100):
-	offsettype = "short"
-else:
-	offsettype = "char"
+def get_value_type(maxvalue):
+    #Use type large enough to fit the table
+    if (maxvalue >= 0x10000):
+            return "int"
+    elif (maxvalue >= 0x100):
+            return "short"
+    else:
+            return "char"
 
 # Pretty print output
 for array in output.keys():
-    
-    sys.stdout.write("static unsigned %s %s[] = {\n" % (offsettype, array))
-    sys.stdout.write(",\n".join(output[array]))
+    otype = get_value_type(max(output[array]))
+    odata = []
+    for value in output[array]:
+        odata.append("0x%x" % value)
+    sys.stdout.write("static unsigned %s %s[] = {\n" % (otype, array))
+    sys.stdout.write(",\n".join(odata))
     sys.stdout.write('\n};\n');
-- 
1.7.11.4

